ðŸ”· Problem Summary â€” 3Sum (LeetCode #15)
You are given an array of integers nums.
Your task is to find all unique triplets [a, b, c] such that:
a + b + c == 0
âœ… Each triplet must be unique
âœ… You cannot use the same number more than once in a triplet
âœ… You may return the answer in any order
________________________________________
âœ¨ Example:
nums = [-1, 0, 1, 2, -1, -4]
Output: [[-1, -1, 2], [-1, 0, 1]]
________________________________________
âœ… Code
from typing import List

class Solution:
  def threeSum(self, nums: List[int]) -> List[List[int]]:
    n = len(nums)
    if n < 3:
      return []
      
    nums.sort()
    res = []
    
    for i in range(n - 2):
      if nums[i] > 0:
        break
      if i > 0 and nums[i] == nums[i - 1]:
        continue

      left, right = i + 1, n - 1
      
      while left < right:
        total = nums[i] + nums[left] + nums[right]
        
        if total == 0:
          res.append([nums[i], nums[left], nums[right]])
          left += 1
          right -= 1
          while left < right and nums[left] == nums[left - 1]:
            left += 1
          while left < right and nums[right] == nums[right + 1]:
            right -= 1
            
        elif total < 0:
          left += 1
        else:
          right -= 1
          
    return res
________________________________________
ðŸ§µ Line-by-Line & Word-by-Word Breakdown
________________________________________
from typing import List
â€¢	Importing List for type hints: helps indicate what types we're working with.
________________________________________
class Solution:
â€¢	Standard LeetCode class declaration.
â€¢	All our logic lives inside this class.
________________________________________
def threeSum(self, nums: List[int]) -> List[List[int]]:
â€¢	threeSum: the name of the function LeetCode will call.
â€¢	nums: the input list of integers.
â€¢	-> List[List[int]]: this function returns a list of integer triplets (like [[-1, 0, 1], [-1, -1, 2]]).
________________________________________
n = len(nums)
â€¢	Store the length of the input list in n.
________________________________________
if n < 3: return []
â€¢	If there are fewer than 3 numbers, you can't make a triplet â†’ return an empty list.
________________________________________
nums.sort()
â€¢	Sorting is essential:
o	Helps us skip duplicates easily.
o	Makes two-pointer strategy work correctly.
o	Sorted input: easier to reason about.
________________________________________
res = []
â€¢	An empty list to collect our valid triplets.
________________________________________
for i in range(n - 2):
â€¢	We iterate from index 0 to n-3.
â€¢	Because we always need 3 elements: nums[i], nums[left], nums[right].
________________________________________
if nums[i] > 0: break
â€¢	Once nums[i] becomes positive, all numbers after it will also be positive.
â€¢	And positive + positive + positive â‰  0 â†’ no valid triplet after this â†’ exit early.
________________________________________
if i > 0 and nums[i] == nums[i - 1]: continue
â€¢	Skip duplicate values for the first number.
â€¢	This avoids counting the same triplet more than once.
________________________________________
left, right = i + 1, n - 1
â€¢	After choosing nums[i], we use two pointers:
o	left starts just after i
o	right starts at the end of the list
________________________________________
while left < right:
â€¢	As long as the two pointers donâ€™t cross each other, keep looking.
________________________________________
total = nums[i] + nums[left] + nums[right]
â€¢	Calculate the sum of the triplet.
________________________________________
if total == 0:
â€¢	Found a valid triplet! ðŸŽ¯
________________________________________
res.append([nums[i], nums[left], nums[right]])
â€¢	Add the triplet to the result.
________________________________________
left += 1, right -= 1
â€¢	Move both pointers inward to find new pairs.
________________________________________
while left < right and nums[left] == nums[left - 1]: left += 1
â€¢	Skip duplicate values for left.
________________________________________
while left < right and nums[right] == nums[right + 1]: right -= 1
â€¢	Skip duplicate values for right.
________________________________________
elif total < 0: left += 1
â€¢	If the sum is too small, move left to a larger number.
________________________________________
else: right -= 1
â€¢	If the sum is too big, move right to a smaller number.
________________________________________
return res
â€¢	Return the final list of unique triplets.
________________________________________
ðŸ§ª Example Walkthrough
nums = [-1, 0, 1, 2, -1, -4]
Step 1: Sort it
nums = [-4, -1, -1, 0, 1, 2]
Step 2: Start loop
â€¢	i = 0: nums[i] = -4 â†’ left = 1, right = 5
o	Try: -4 + (-1) + 2 = -3 â†’ too small â†’ move left
o	-4 + 0 + 2 = -2 â†’ still small â†’ move left
o	-4 + 1 + 2 = -1 â†’ still small â†’ move left
â€¢	i = 1: nums[i] = -1 â†’ left = 2, right = 5
o	-1 + (-1) + 2 = 0 â†’ âœ… found triplet
o	Skip duplicate -1s
o	Continueâ€¦
â€¢	i = 2: skip (duplicate -1)
â†’ Final answer: [[-1, -1, 2], [-1, 0, 1]]
________________________________________
â±ï¸ Time & Space Complexity
Aspect	Value
Time Complexity	O(nÂ²)
Space Complexity	O(1) (excluding result list)
â€¢	Sorting: O(n log n)
â€¢	Outer loop: O(n)
â€¢	Inner two-pointer loop: O(n)
â†’ Together: O(nÂ²)
________________________________________
âœ… Final Thoughts
This solution is:
â€¢	Clean
â€¢	Efficient
â€¢	Beginner-friendly
It teaches:
â€¢	Sorting logic
â€¢	Two-pointer technique
â€¢	How to avoid duplicates
â€¢	Efficient iteration

